// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc_server.proto

/*
Package qlik is a generated protocol buffer package.

It is generated from these files:
	grpc_server.proto

It has these top-level messages:
	ConnectionInfo
	SessionInfo
	DataInfo
	GetDataOptions
	DataChunk
	FieldAttributes
	FieldInfo
	GetDataResponse
*/
package qlik

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// * How to interpret the data.
// If dates already in the 1899-12-30 format, then the fastest way to import then is to use SemanticType=DEFAULT.
// And transferr the date as a double and set FieldAttributes::Type = DATE.
// If the dates are in "days since 1904-01-01" format the best way is to add 1462 to them and send as
// 1899-12-30 dates.
type SemanticType int32

const (
	SemanticType_DEFAULT                     SemanticType = 0
	SemanticType_UNIX_SECONDS_SINCE_1970_UTC SemanticType = 1
	SemanticType_ISO_8601                    SemanticType = 2
)

var SemanticType_name = map[int32]string{
	0: "DEFAULT",
	1: "UNIX_SECONDS_SINCE_1970_UTC",
	2: "ISO_8601",
}
var SemanticType_value = map[string]int32{
	"DEFAULT":                     0,
	"UNIX_SECONDS_SINCE_1970_UTC": 1,
	"ISO_8601":                    2,
}

func (x SemanticType) String() string {
	return proto.EnumName(SemanticType_name, int32(x))
}
func (SemanticType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// * Direct copy of FieldAttrType in Qlik Engine. How to display the data.
type FieldAttrType int32

const (
	FieldAttrType_UNKNOWN   FieldAttrType = 0
	FieldAttrType_TEXT      FieldAttrType = 1
	FieldAttrType_REAL      FieldAttrType = 2
	FieldAttrType_DATE      FieldAttrType = 3
	FieldAttrType_TIME      FieldAttrType = 4
	FieldAttrType_TIMESTAMP FieldAttrType = 5
	FieldAttrType_INTERVAL  FieldAttrType = 6
	FieldAttrType_INTEGER   FieldAttrType = 10
	FieldAttrType_FIX       FieldAttrType = 11
	FieldAttrType_MONEY     FieldAttrType = 12
)

var FieldAttrType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "TEXT",
	2:  "REAL",
	3:  "DATE",
	4:  "TIME",
	5:  "TIMESTAMP",
	6:  "INTERVAL",
	10: "INTEGER",
	11: "FIX",
	12: "MONEY",
}
var FieldAttrType_value = map[string]int32{
	"UNKNOWN":   0,
	"TEXT":      1,
	"REAL":      2,
	"DATE":      3,
	"TIME":      4,
	"TIMESTAMP": 5,
	"INTERVAL":  6,
	"INTEGER":   10,
	"FIX":       11,
	"MONEY":     12,
}

func (x FieldAttrType) String() string {
	return proto.EnumName(FieldAttrType_name, int32(x))
}
func (FieldAttrType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ConnectionInfo struct {
	ConnectionString string `protobuf:"bytes,1,opt,name=connectionString" json:"connectionString,omitempty"`
	User             string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Password         string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
}

func (m *ConnectionInfo) Reset()                    { *m = ConnectionInfo{} }
func (m *ConnectionInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnectionInfo) ProtoMessage()               {}
func (*ConnectionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConnectionInfo) GetConnectionString() string {
	if m != nil {
		return m.ConnectionString
	}
	return ""
}

func (m *ConnectionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ConnectionInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type SessionInfo struct {
	User      string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	SessionId string `protobuf:"bytes,2,opt,name=sessionId" json:"sessionId,omitempty"`
	DocId     string `protobuf:"bytes,3,opt,name=docId" json:"docId,omitempty"`
}

func (m *SessionInfo) Reset()                    { *m = SessionInfo{} }
func (m *SessionInfo) String() string            { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()               {}
func (*SessionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *SessionInfo) GetDocId() string {
	if m != nil {
		return m.DocId
	}
	return ""
}

type DataInfo struct {
	Statement           string `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
	StatementParameters string `protobuf:"bytes,2,opt,name=statementParameters" json:"statementParameters,omitempty"`
}

func (m *DataInfo) Reset()                    { *m = DataInfo{} }
func (m *DataInfo) String() string            { return proto.CompactTextString(m) }
func (*DataInfo) ProtoMessage()               {}
func (*DataInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DataInfo) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *DataInfo) GetStatementParameters() string {
	if m != nil {
		return m.StatementParameters
	}
	return ""
}

type GetDataOptions struct {
	Connection  *ConnectionInfo `protobuf:"bytes,1,opt,name=connection" json:"connection,omitempty"`
	SessionInfo *SessionInfo    `protobuf:"bytes,2,opt,name=sessionInfo" json:"sessionInfo,omitempty"`
	Parameters  *DataInfo       `protobuf:"bytes,3,opt,name=parameters" json:"parameters,omitempty"`
}

func (m *GetDataOptions) Reset()                    { *m = GetDataOptions{} }
func (m *GetDataOptions) String() string            { return proto.CompactTextString(m) }
func (*GetDataOptions) ProtoMessage()               {}
func (*GetDataOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetDataOptions) GetConnection() *ConnectionInfo {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *GetDataOptions) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

func (m *GetDataOptions) GetParameters() *DataInfo {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// *
// A structure for streaming field values.
//
// This message conatins two parts. A value array part and a pointer part.
//
// Every transferred value have a string index and a numeric index. These indicies can be -1 to indicate null.
// Otherwise they can point into the value arrays.
// The numberIndex have a special mechanism to escape an integer value inline with -2.
//
// A value with a null string and a null number is a null value in the Qlik Engine.
//
// Each chunk starts anywhere in any row and continues for an arbitary length and may wrap to
// another row. Typically sized to fit 64 KB.
//
// Each DataChunk must be equal or less in size to the default Grpc message size limit. This is
// currently 4 mB.
//
// But should be between 50 kB (good) to 64 kB (best) for best performance.
// Its not easy to make a message exactly 64 kb in size but just under that will be perfectly fine
// as well.
//
// Very large strings can be sent in many DataChunk messages by using the -3 escape sequence.
type DataChunk struct {
	// Value arrays
	StringValues []string  `protobuf:"bytes,1,rep,name=stringValues" json:"stringValues,omitempty"`
	DoubleValues []float64 `protobuf:"fixed64,2,rep,packed,name=doubleValues" json:"doubleValues,omitempty"`
	// Pointer arrays
	StringIndex []int32 `protobuf:"zigzag32,3,rep,packed,name=stringIndex" json:"stringIndex,omitempty"`
	NumberIndex []int64 `protobuf:"zigzag64,4,rep,packed,name=numberIndex" json:"numberIndex,omitempty"`
}

func (m *DataChunk) Reset()                    { *m = DataChunk{} }
func (m *DataChunk) String() string            { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()               {}
func (*DataChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DataChunk) GetStringValues() []string {
	if m != nil {
		return m.StringValues
	}
	return nil
}

func (m *DataChunk) GetDoubleValues() []float64 {
	if m != nil {
		return m.DoubleValues
	}
	return nil
}

func (m *DataChunk) GetStringIndex() []int32 {
	if m != nil {
		return m.StringIndex
	}
	return nil
}

func (m *DataChunk) GetNumberIndex() []int64 {
	if m != nil {
		return m.NumberIndex
	}
	return nil
}

// * Subset of classic Qlik Engine number format
type FieldAttributes struct {
	Type FieldAttrType `protobuf:"varint,1,opt,name=Type,enum=qlik.FieldAttrType" json:"Type,omitempty"`
}

func (m *FieldAttributes) Reset()                    { *m = FieldAttributes{} }
func (m *FieldAttributes) String() string            { return proto.CompactTextString(m) }
func (*FieldAttributes) ProtoMessage()               {}
func (*FieldAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FieldAttributes) GetType() FieldAttrType {
	if m != nil {
		return m.Type
	}
	return FieldAttrType_UNKNOWN
}

type FieldInfo struct {
	Name            string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	SemanticType    SemanticType     `protobuf:"varint,2,opt,name=semanticType,enum=qlik.SemanticType" json:"semanticType,omitempty"`
	FieldAttributes *FieldAttributes `protobuf:"bytes,3,opt,name=fieldAttributes" json:"fieldAttributes,omitempty"`
	Tags            []string         `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *FieldInfo) Reset()                    { *m = FieldInfo{} }
func (m *FieldInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldInfo) ProtoMessage()               {}
func (*FieldInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FieldInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldInfo) GetSemanticType() SemanticType {
	if m != nil {
		return m.SemanticType
	}
	return SemanticType_DEFAULT
}

func (m *FieldInfo) GetFieldAttributes() *FieldAttributes {
	if m != nil {
		return m.FieldAttributes
	}
	return nil
}

func (m *FieldInfo) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// * Transferred as initial metadata with the name "x-qlik-getdata-bin".
type GetDataResponse struct {
	FieldInfo []*FieldInfo `protobuf:"bytes,1,rep,name=fieldInfo" json:"fieldInfo,omitempty"`
	TableName string       `protobuf:"bytes,2,opt,name=tableName" json:"tableName,omitempty"`
}

func (m *GetDataResponse) Reset()                    { *m = GetDataResponse{} }
func (m *GetDataResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDataResponse) ProtoMessage()               {}
func (*GetDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetDataResponse) GetFieldInfo() []*FieldInfo {
	if m != nil {
		return m.FieldInfo
	}
	return nil
}

func (m *GetDataResponse) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func init() {
	proto.RegisterType((*ConnectionInfo)(nil), "qlik.ConnectionInfo")
	proto.RegisterType((*SessionInfo)(nil), "qlik.SessionInfo")
	proto.RegisterType((*DataInfo)(nil), "qlik.DataInfo")
	proto.RegisterType((*GetDataOptions)(nil), "qlik.GetDataOptions")
	proto.RegisterType((*DataChunk)(nil), "qlik.DataChunk")
	proto.RegisterType((*FieldAttributes)(nil), "qlik.FieldAttributes")
	proto.RegisterType((*FieldInfo)(nil), "qlik.FieldInfo")
	proto.RegisterType((*GetDataResponse)(nil), "qlik.GetDataResponse")
	proto.RegisterEnum("qlik.SemanticType", SemanticType_name, SemanticType_value)
	proto.RegisterEnum("qlik.FieldAttrType", FieldAttrType_name, FieldAttrType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Connector service

type ConnectorClient interface {
	// * The standard way to send data.
	// First send GetDataResponse as initial meta data.
	// Then send DataChunk stream.
	GetData(ctx context.Context, in *GetDataOptions, opts ...grpc.CallOption) (Connector_GetDataClient, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) GetData(ctx context.Context, in *GetDataOptions, opts ...grpc.CallOption) (Connector_GetDataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Connector_serviceDesc.Streams[0], c.cc, "/qlik.Connector/GetData", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorGetDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connector_GetDataClient interface {
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type connectorGetDataClient struct {
	grpc.ClientStream
}

func (x *connectorGetDataClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Connector service

type ConnectorServer interface {
	// * The standard way to send data.
	// First send GetDataResponse as initial meta data.
	// Then send DataChunk stream.
	GetData(*GetDataOptions, Connector_GetDataServer) error
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_GetData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDataOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectorServer).GetData(m, &connectorGetDataServer{stream})
}

type Connector_GetDataServer interface {
	Send(*DataChunk) error
	grpc.ServerStream
}

type connectorGetDataServer struct {
	grpc.ServerStream
}

func (x *connectorGetDataServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qlik.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetData",
			Handler:       _Connector_GetData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc_server.proto",
}

func init() { proto.RegisterFile("grpc_server.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 671 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0x4d, 0x6f, 0xda, 0x40,
	0x10, 0x8d, 0x31, 0x49, 0xf0, 0x98, 0xc0, 0x66, 0x93, 0x4a, 0x28, 0xad, 0x54, 0xe4, 0x4b, 0x51,
	0xa4, 0x22, 0x42, 0xa2, 0xf4, 0xe3, 0x52, 0x21, 0x70, 0x22, 0xb7, 0x89, 0x89, 0xd6, 0x26, 0x4d,
	0x7b, 0x28, 0x32, 0xb0, 0x49, 0x51, 0xc0, 0x76, 0xbd, 0x4b, 0x3f, 0xae, 0xfd, 0x13, 0xfd, 0x11,
	0xed, 0x8f, 0xac, 0x76, 0x6d, 0x63, 0x3b, 0xed, 0x6d, 0xf6, 0xcd, 0x9b, 0x37, 0x3b, 0xcf, 0xb3,
	0x86, 0xdd, 0xbb, 0x28, 0x9c, 0x8e, 0x19, 0x8d, 0xbe, 0xd2, 0xa8, 0x1d, 0x46, 0x01, 0x0f, 0x70,
	0xf9, 0xcb, 0x62, 0x7e, 0x6f, 0x2c, 0xa0, 0xd6, 0x0f, 0x7c, 0x9f, 0x4e, 0xf9, 0x3c, 0xf0, 0x2d,
	0xff, 0x36, 0xc0, 0x87, 0x80, 0xa6, 0x6b, 0xc4, 0xe1, 0xd1, 0xdc, 0xbf, 0x6b, 0x28, 0x4d, 0xa5,
	0xa5, 0x91, 0x7f, 0x70, 0x8c, 0xa1, 0xbc, 0x62, 0x34, 0x6a, 0x94, 0x64, 0x5e, 0xc6, 0xf8, 0x00,
	0x2a, 0xa1, 0xc7, 0xd8, 0xb7, 0x20, 0x9a, 0x35, 0x54, 0x89, 0xaf, 0xcf, 0xc6, 0x08, 0x74, 0x87,
	0x32, 0x96, 0xb6, 0x4a, 0xcb, 0x95, 0x5c, 0xf9, 0x13, 0xd0, 0x58, 0x42, 0x99, 0x25, 0xba, 0x19,
	0x80, 0xf7, 0x61, 0x73, 0x16, 0x4c, 0xad, 0x54, 0x39, 0x3e, 0x18, 0x1f, 0xa1, 0x32, 0xf0, 0xb8,
	0x27, 0x35, 0x45, 0x3d, 0xf7, 0x38, 0x5d, 0x52, 0x9f, 0x27, 0xc2, 0x19, 0x80, 0x3b, 0xb0, 0xb7,
	0x3e, 0x5c, 0x79, 0x91, 0xb7, 0xa4, 0x9c, 0x46, 0x2c, 0xe9, 0xf3, 0xbf, 0x94, 0xf1, 0x5b, 0x81,
	0xda, 0x39, 0xe5, 0x42, 0x7f, 0x18, 0x8a, 0xd1, 0x19, 0x3e, 0x01, 0xc8, 0x9c, 0x90, 0x3d, 0xf4,
	0xee, 0x7e, 0x5b, 0xd8, 0xd9, 0x2e, 0x7a, 0x49, 0x72, 0x3c, 0x7c, 0x0c, 0x3a, 0xcb, 0x66, 0x97,
	0x2d, 0xf5, 0xee, 0x6e, 0x5c, 0x96, 0x33, 0x85, 0xe4, 0x59, 0xb8, 0x0d, 0x10, 0x66, 0xd7, 0x54,
	0x65, 0x4d, 0x2d, 0xae, 0x49, 0x27, 0x26, 0x39, 0x86, 0xf1, 0x4b, 0x01, 0x4d, 0x24, 0xfa, 0x9f,
	0x57, 0xfe, 0x3d, 0x36, 0xa0, 0xca, 0xe4, 0x87, 0xba, 0xf6, 0x16, 0x2b, 0xca, 0x1a, 0x4a, 0x53,
	0x6d, 0x69, 0xa4, 0x80, 0x09, 0xce, 0x2c, 0x58, 0x4d, 0x16, 0x34, 0xe1, 0x94, 0x9a, 0x6a, 0x4b,
	0x21, 0x05, 0x0c, 0x37, 0x41, 0x8f, 0x6b, 0x2c, 0x7f, 0x46, 0xbf, 0x37, 0xd4, 0xa6, 0xda, 0xda,
	0x25, 0x79, 0x48, 0x30, 0xfc, 0xd5, 0x72, 0x42, 0xa3, 0x98, 0x51, 0x6e, 0xaa, 0x2d, 0x4c, 0xf2,
	0x90, 0xf1, 0x1a, 0xea, 0x67, 0x73, 0xba, 0x98, 0xf5, 0x38, 0x8f, 0xe6, 0x93, 0x15, 0xa7, 0x0c,
	0x3f, 0x83, 0xb2, 0xfb, 0x23, 0xa4, 0xd2, 0xc1, 0x5a, 0x77, 0x2f, 0x1e, 0x6b, 0x4d, 0x12, 0x29,
	0x22, 0x09, 0xc6, 0x1f, 0x05, 0x34, 0x89, 0xa7, 0x5b, 0xe3, 0x7b, 0x4b, 0x9a, 0x6e, 0x8d, 0x88,
	0xf1, 0x29, 0x54, 0x19, 0x5d, 0x7a, 0x3e, 0x9f, 0x4f, 0xa5, 0x64, 0x49, 0x4a, 0xe2, 0xd4, 0xdd,
	0x2c, 0x43, 0x0a, 0x3c, 0xfc, 0x06, 0xea, 0xb7, 0xc5, 0x5b, 0x25, 0x26, 0x3f, 0x7a, 0x70, 0x9b,
	0x38, 0x49, 0x1e, 0xb2, 0xc5, 0x65, 0xb8, 0x77, 0xc7, 0xe4, 0xc4, 0x1a, 0x91, 0xb1, 0xf1, 0x09,
	0xea, 0xc9, 0xc6, 0x10, 0xca, 0xc2, 0xc0, 0x67, 0x14, 0x3f, 0x07, 0xed, 0x36, 0x1d, 0x40, 0x7e,
	0x06, 0xbd, 0x5b, 0xcf, 0x75, 0x90, 0xdf, 0x31, 0x63, 0x88, 0x25, 0xe6, 0xde, 0x64, 0x41, 0x6d,
	0x31, 0x67, 0xf2, 0x08, 0xd6, 0xc0, 0xe1, 0x5b, 0xa8, 0xe6, 0x47, 0xc2, 0x3a, 0x6c, 0x0f, 0xcc,
	0xb3, 0xde, 0xe8, 0xc2, 0x45, 0x1b, 0xf8, 0x29, 0x3c, 0x1e, 0xd9, 0xd6, 0xcd, 0xd8, 0x31, 0xfb,
	0x43, 0x7b, 0xe0, 0x8c, 0x1d, 0xcb, 0xee, 0x9b, 0xe3, 0xa3, 0x57, 0x2f, 0x3a, 0xe3, 0x91, 0xdb,
	0x47, 0x0a, 0xae, 0x42, 0xc5, 0x72, 0x86, 0xe3, 0x97, 0xa7, 0x9d, 0x23, 0x54, 0x3a, 0xfc, 0xa9,
	0xc0, 0x4e, 0xc1, 0x72, 0xa1, 0x36, 0xb2, 0xdf, 0xd9, 0xc3, 0xf7, 0x36, 0xda, 0xc0, 0x15, 0x28,
	0xbb, 0xe6, 0x8d, 0x8b, 0x14, 0x11, 0x11, 0xb3, 0x77, 0x81, 0x4a, 0x22, 0x1a, 0xf4, 0x5c, 0x13,
	0xa9, 0x32, 0x6b, 0x5d, 0x9a, 0xa8, 0x8c, 0x77, 0x40, 0x13, 0x91, 0xe3, 0xf6, 0x2e, 0xaf, 0xd0,
	0xa6, 0xec, 0x61, 0xbb, 0x26, 0xb9, 0xee, 0x5d, 0xa0, 0x2d, 0xa1, 0x28, 0x4e, 0xe7, 0x26, 0x41,
	0x80, 0xb7, 0x41, 0x3d, 0xb3, 0x6e, 0x90, 0x8e, 0x35, 0xd8, 0xbc, 0x1c, 0xda, 0xe6, 0x07, 0x54,
	0xed, 0xf6, 0x40, 0x4b, 0x1e, 0x4e, 0x10, 0xe1, 0x13, 0xd8, 0x4e, 0xdc, 0xc3, 0xc9, 0xa3, 0x2a,
	0x3e, 0xbf, 0x83, 0x7a, 0xb6, 0xff, 0x72, 0xcd, 0x8d, 0x8d, 0x8e, 0x32, 0xd9, 0x92, 0x3f, 0xb5,
	0xe3, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x89, 0x5f, 0x74, 0xe9, 0x04, 0x00, 0x00,
}

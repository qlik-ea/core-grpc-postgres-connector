// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc_server.proto

/*
Package qlik_connect is a generated protocol buffer package.

It is generated from these files:
	grpc_server.proto

It has these top-level messages:
	ConnectionInfo
	SessionInfo
	Parameter
	DataInfo
	DataRequest
	DataChunk
	FieldAttributes
	FieldInfo
	GetDataResponse
	MetaInfo
	MetaInfoRequest
*/
package qlik_connect

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// * How to interpret the data.
// If dates or times are already in the Qlik Engine format (fractional day since 1899-12-30), then the fastest way
// to import is to use SemanticType=DEFAULT. And transferr the date as a double and set FieldAttributes::Type = DATE.
// If the dates are in "days since 1904-01-01" format the best way is to add 1462 to them and send as
// 1899-12-30 dates.
type SemanticType int32

const (
	SemanticType_DEFAULT                     SemanticType = 0
	SemanticType_UNIX_SECONDS_SINCE_1970_UTC SemanticType = 1
	SemanticType_ISO_8601                    SemanticType = 2
)

var SemanticType_name = map[int32]string{
	0: "DEFAULT",
	1: "UNIX_SECONDS_SINCE_1970_UTC",
	2: "ISO_8601",
}
var SemanticType_value = map[string]int32{
	"DEFAULT":                     0,
	"UNIX_SECONDS_SINCE_1970_UTC": 1,
	"ISO_8601":                    2,
}

func (x SemanticType) String() string {
	return proto.EnumName(SemanticType_name, int32(x))
}
func (SemanticType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// * Direct copy of FieldAttrType in Qlik Engine. How to display the data.
type FieldAttrType int32

const (
	FieldAttrType_UNKNOWN   FieldAttrType = 0
	FieldAttrType_TEXT      FieldAttrType = 1
	FieldAttrType_REAL      FieldAttrType = 2
	FieldAttrType_DATE      FieldAttrType = 3
	FieldAttrType_TIME      FieldAttrType = 4
	FieldAttrType_TIMESTAMP FieldAttrType = 5
	FieldAttrType_INTERVAL  FieldAttrType = 6
	FieldAttrType_INTEGER   FieldAttrType = 10
	FieldAttrType_FIX       FieldAttrType = 11
	FieldAttrType_MONEY     FieldAttrType = 12
)

var FieldAttrType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "TEXT",
	2:  "REAL",
	3:  "DATE",
	4:  "TIME",
	5:  "TIMESTAMP",
	6:  "INTERVAL",
	10: "INTEGER",
	11: "FIX",
	12: "MONEY",
}
var FieldAttrType_value = map[string]int32{
	"UNKNOWN":   0,
	"TEXT":      1,
	"REAL":      2,
	"DATE":      3,
	"TIME":      4,
	"TIMESTAMP": 5,
	"INTERVAL":  6,
	"INTEGER":   10,
	"FIX":       11,
	"MONEY":     12,
}

func (x FieldAttrType) String() string {
	return proto.EnumName(FieldAttrType_name, int32(x))
}
func (FieldAttrType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ConnectionInfo struct {
	ConnectionString string `protobuf:"bytes,1,opt,name=connectionString" json:"connectionString,omitempty"`
	User             string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Password         string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
}

func (m *ConnectionInfo) Reset()                    { *m = ConnectionInfo{} }
func (m *ConnectionInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnectionInfo) ProtoMessage()               {}
func (*ConnectionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConnectionInfo) GetConnectionString() string {
	if m != nil {
		return m.ConnectionString
	}
	return ""
}

func (m *ConnectionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ConnectionInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type SessionInfo struct {
	User      string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	SessionId string `protobuf:"bytes,2,opt,name=sessionId" json:"sessionId,omitempty"`
	DocId     string `protobuf:"bytes,3,opt,name=docId" json:"docId,omitempty"`
}

func (m *SessionInfo) Reset()                    { *m = SessionInfo{} }
func (m *SessionInfo) String() string            { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()               {}
func (*SessionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *SessionInfo) GetDocId() string {
	if m != nil {
		return m.DocId
	}
	return ""
}

type Parameter struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type DataInfo struct {
	Statement  string       `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
	Parameters []*Parameter `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty"`
}

func (m *DataInfo) Reset()                    { *m = DataInfo{} }
func (m *DataInfo) String() string            { return proto.CompactTextString(m) }
func (*DataInfo) ProtoMessage()               {}
func (*DataInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DataInfo) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *DataInfo) GetParameters() []*Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type DataRequest struct {
	Connection  *ConnectionInfo `protobuf:"bytes,1,opt,name=connection" json:"connection,omitempty"`
	SessionInfo *SessionInfo    `protobuf:"bytes,2,opt,name=sessionInfo" json:"sessionInfo,omitempty"`
	Parameters  *DataInfo       `protobuf:"bytes,3,opt,name=parameters" json:"parameters,omitempty"`
}

func (m *DataRequest) Reset()                    { *m = DataRequest{} }
func (m *DataRequest) String() string            { return proto.CompactTextString(m) }
func (*DataRequest) ProtoMessage()               {}
func (*DataRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DataRequest) GetConnection() *ConnectionInfo {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *DataRequest) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

func (m *DataRequest) GetParameters() *DataInfo {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// *
// A structure for streaming field values.
//
// This message conatins two parts. A value bucket part and a code part.
//
// Every transferred value have a string code and one or two numeric codes.
// These codes can be negative to inicate special things. -1 indicates null for example.
//
// Otherwise they can index into the value buckets.
// A value with a null string and a null number is a null value in the Qlik Engine.
//
// Number code have a special mechanism to escape an integer value inline with -2.
//
// Each chunk starts anywhere in any row and continues for an arbitary length and may wrap to
// another row. A DataChunk will typically transfer many rows.
//
// Each DataChunk must be equal or less in size to the default Grpc message size limit. This is
// currently 4 MB.
//
// 64 KB or slightly less is the optimal size for bandwith performance. But anything from
// 20 to 120 KB will give good performance if used with the hint option when
// writing.
//
// Very large strings can be sent in many DataChunk messages by using the -3 escape sequence.
type DataChunk struct {
	// Value buckets
	StringBucket []string  `protobuf:"bytes,1,rep,name=stringBucket" json:"stringBucket,omitempty"`
	DoubleBucket []float64 `protobuf:"fixed64,2,rep,packed,name=doubleBucket" json:"doubleBucket,omitempty"`
	// Code arrays
	StringCodes []int32 `protobuf:"zigzag32,3,rep,packed,name=stringCodes" json:"stringCodes,omitempty"`
	NumberCodes []int64 `protobuf:"zigzag64,4,rep,packed,name=numberCodes" json:"numberCodes,omitempty"`
}

func (m *DataChunk) Reset()                    { *m = DataChunk{} }
func (m *DataChunk) String() string            { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()               {}
func (*DataChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DataChunk) GetStringBucket() []string {
	if m != nil {
		return m.StringBucket
	}
	return nil
}

func (m *DataChunk) GetDoubleBucket() []float64 {
	if m != nil {
		return m.DoubleBucket
	}
	return nil
}

func (m *DataChunk) GetStringCodes() []int32 {
	if m != nil {
		return m.StringCodes
	}
	return nil
}

func (m *DataChunk) GetNumberCodes() []int64 {
	if m != nil {
		return m.NumberCodes
	}
	return nil
}

// * Subset of classic Qlik Engine number format
type FieldAttributes struct {
	Type FieldAttrType `protobuf:"varint,1,opt,name=Type,enum=qlik.connect.FieldAttrType" json:"Type,omitempty"`
}

func (m *FieldAttributes) Reset()                    { *m = FieldAttributes{} }
func (m *FieldAttributes) String() string            { return proto.CompactTextString(m) }
func (*FieldAttributes) ProtoMessage()               {}
func (*FieldAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FieldAttributes) GetType() FieldAttrType {
	if m != nil {
		return m.Type
	}
	return FieldAttrType_UNKNOWN
}

type FieldInfo struct {
	Name            string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	SemanticType    SemanticType     `protobuf:"varint,2,opt,name=semanticType,enum=qlik.connect.SemanticType" json:"semanticType,omitempty"`
	FieldAttributes *FieldAttributes `protobuf:"bytes,3,opt,name=fieldAttributes" json:"fieldAttributes,omitempty"`
	Tags            []string         `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *FieldInfo) Reset()                    { *m = FieldInfo{} }
func (m *FieldInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldInfo) ProtoMessage()               {}
func (*FieldInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FieldInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldInfo) GetSemanticType() SemanticType {
	if m != nil {
		return m.SemanticType
	}
	return SemanticType_DEFAULT
}

func (m *FieldInfo) GetFieldAttributes() *FieldAttributes {
	if m != nil {
		return m.FieldAttributes
	}
	return nil
}

func (m *FieldInfo) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// * Transferred as initial metadata with the name "x-qlik-getdata-bin".
type GetDataResponse struct {
	FieldInfo []*FieldInfo `protobuf:"bytes,1,rep,name=fieldInfo" json:"fieldInfo,omitempty"`
	TableName string       `protobuf:"bytes,2,opt,name=tableName" json:"tableName,omitempty"`
}

func (m *GetDataResponse) Reset()                    { *m = GetDataResponse{} }
func (m *GetDataResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDataResponse) ProtoMessage()               {}
func (*GetDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetDataResponse) GetFieldInfo() []*FieldInfo {
	if m != nil {
		return m.FieldInfo
	}
	return nil
}

func (m *GetDataResponse) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

// *
// Usefull for debugging.
type MetaInfo struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	// /     Example: "1.0.0.0" or "1.23 Beta" or "Buildnumber: 1234" or "2018-Feb-06"
	Developer string `protobuf:"bytes,3,opt,name=developer" json:"developer,omitempty"`
}

func (m *MetaInfo) Reset()                    { *m = MetaInfo{} }
func (m *MetaInfo) String() string            { return proto.CompactTextString(m) }
func (*MetaInfo) ProtoMessage()               {}
func (*MetaInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *MetaInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetaInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *MetaInfo) GetDeveloper() string {
	if m != nil {
		return m.Developer
	}
	return ""
}

type MetaInfoRequest struct {
}

func (m *MetaInfoRequest) Reset()                    { *m = MetaInfoRequest{} }
func (m *MetaInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*MetaInfoRequest) ProtoMessage()               {}
func (*MetaInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func init() {
	proto.RegisterType((*ConnectionInfo)(nil), "qlik.connect.ConnectionInfo")
	proto.RegisterType((*SessionInfo)(nil), "qlik.connect.SessionInfo")
	proto.RegisterType((*Parameter)(nil), "qlik.connect.Parameter")
	proto.RegisterType((*DataInfo)(nil), "qlik.connect.DataInfo")
	proto.RegisterType((*DataRequest)(nil), "qlik.connect.DataRequest")
	proto.RegisterType((*DataChunk)(nil), "qlik.connect.DataChunk")
	proto.RegisterType((*FieldAttributes)(nil), "qlik.connect.FieldAttributes")
	proto.RegisterType((*FieldInfo)(nil), "qlik.connect.FieldInfo")
	proto.RegisterType((*GetDataResponse)(nil), "qlik.connect.GetDataResponse")
	proto.RegisterType((*MetaInfo)(nil), "qlik.connect.MetaInfo")
	proto.RegisterType((*MetaInfoRequest)(nil), "qlik.connect.MetaInfoRequest")
	proto.RegisterEnum("qlik.connect.SemanticType", SemanticType_name, SemanticType_value)
	proto.RegisterEnum("qlik.connect.FieldAttrType", FieldAttrType_name, FieldAttrType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Connector service

type ConnectorClient interface {
	// * The standard way to send data.
	// First send GetDataResponse as initial meta data.
	// Then send DataChunk stream.
	GetData(ctx context.Context, in *DataRequest, opts ...grpc.CallOption) (Connector_GetDataClient, error)
	GetMetaInfo(ctx context.Context, in *MetaInfoRequest, opts ...grpc.CallOption) (*MetaInfo, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) GetData(ctx context.Context, in *DataRequest, opts ...grpc.CallOption) (Connector_GetDataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Connector_serviceDesc.Streams[0], c.cc, "/qlik.connect.Connector/GetData", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorGetDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connector_GetDataClient interface {
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type connectorGetDataClient struct {
	grpc.ClientStream
}

func (x *connectorGetDataClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *connectorClient) GetMetaInfo(ctx context.Context, in *MetaInfoRequest, opts ...grpc.CallOption) (*MetaInfo, error) {
	out := new(MetaInfo)
	err := grpc.Invoke(ctx, "/qlik.connect.Connector/GetMetaInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Connector service

type ConnectorServer interface {
	// * The standard way to send data.
	// First send GetDataResponse as initial meta data.
	// Then send DataChunk stream.
	GetData(*DataRequest, Connector_GetDataServer) error
	GetMetaInfo(context.Context, *MetaInfoRequest) (*MetaInfo, error)
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_GetData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DataRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectorServer).GetData(m, &connectorGetDataServer{stream})
}

type Connector_GetDataServer interface {
	Send(*DataChunk) error
	grpc.ServerStream
}

type connectorGetDataServer struct {
	grpc.ServerStream
}

func (x *connectorGetDataServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Connector_GetMetaInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetaInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GetMetaInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qlik.connect.Connector/GetMetaInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GetMetaInfo(ctx, req.(*MetaInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qlik.connect.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMetaInfo",
			Handler:    _Connector_GetMetaInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetData",
			Handler:       _Connector_GetData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc_server.proto",
}

func init() { proto.RegisterFile("grpc_server.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 756 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0xc1, 0x6e, 0xe2, 0x48,
	0x10, 0xc5, 0x98, 0x04, 0x5c, 0x26, 0xc1, 0x69, 0xad, 0x12, 0x42, 0xb2, 0x5a, 0xe4, 0x13, 0xca,
	0x81, 0x4d, 0x58, 0x25, 0xd9, 0xd5, 0xae, 0x56, 0x22, 0x60, 0x10, 0xbb, 0xc1, 0x44, 0x8d, 0xc9,
	0x64, 0x4e, 0xc8, 0x40, 0x93, 0x41, 0x01, 0x9b, 0xb8, 0xdb, 0x8c, 0xe6, 0x3a, 0x1f, 0x31, 0xf3,
	0x33, 0x73, 0x98, 0x4f, 0x1b, 0x75, 0xdb, 0x06, 0x1b, 0x32, 0xb7, 0xf2, 0xeb, 0x57, 0xaf, 0xbb,
	0x5e, 0x55, 0xc9, 0x70, 0xf4, 0xec, 0x2d, 0xc7, 0x43, 0x4a, 0xbc, 0x15, 0xf1, 0xaa, 0x4b, 0xcf,
	0x65, 0x2e, 0xca, 0xbf, 0xce, 0x67, 0x2f, 0xd5, 0xb1, 0xeb, 0x38, 0x64, 0xcc, 0xf4, 0x39, 0x1c,
	0x36, 0x82, 0x70, 0xe6, 0x3a, 0x1d, 0x67, 0xea, 0xa2, 0x0b, 0xd0, 0xc6, 0x6b, 0xa4, 0xcf, 0xbc,
	0x99, 0xf3, 0x5c, 0x94, 0xca, 0x52, 0x45, 0xc1, 0x3b, 0x38, 0x42, 0x90, 0xf1, 0x29, 0xf1, 0x8a,
	0x69, 0x71, 0x2e, 0x62, 0x54, 0x82, 0xdc, 0xd2, 0xa6, 0xf4, 0xa3, 0xeb, 0x4d, 0x8a, 0xb2, 0xc0,
	0xd7, 0xdf, 0xfa, 0x00, 0xd4, 0x3e, 0xa1, 0x34, 0xba, 0x2a, 0x4a, 0x97, 0x62, 0xe9, 0xe7, 0xa0,
	0xd0, 0x90, 0x32, 0x09, 0x75, 0x37, 0x00, 0xfa, 0x05, 0xf6, 0x26, 0xee, 0xb8, 0x13, 0x29, 0x07,
	0x1f, 0xfa, 0x35, 0x28, 0x0f, 0xb6, 0x67, 0x2f, 0x08, 0x23, 0x1e, 0x17, 0x75, 0xec, 0x05, 0x89,
	0x44, 0x79, 0xcc, 0xd3, 0x56, 0xf6, 0xdc, 0x27, 0xa1, 0x60, 0xf0, 0xa1, 0xdb, 0x90, 0x6b, 0xda,
	0xcc, 0x16, 0x4f, 0xe1, 0xd7, 0x32, 0x9b, 0x91, 0x05, 0x71, 0x58, 0x98, 0xba, 0x01, 0xd0, 0x2d,
	0xc0, 0x32, 0xba, 0x80, 0x16, 0xd3, 0x65, 0xb9, 0xa2, 0xd6, 0x4e, 0xaa, 0x71, 0x23, 0xab, 0xeb,
	0x07, 0xe0, 0x18, 0x55, 0xff, 0x2e, 0x81, 0xca, 0xef, 0xc0, 0xe4, 0xd5, 0x27, 0x94, 0xa1, 0x7f,
	0x00, 0x36, 0x26, 0x8a, 0x7b, 0xd4, 0xda, 0x79, 0x52, 0x28, 0xd9, 0x0e, 0x1c, 0xe3, 0xa3, 0xbf,
	0x41, 0xa5, 0x1b, 0xfb, 0x44, 0x31, 0x6a, 0xed, 0x34, 0x99, 0x1e, 0xf3, 0x17, 0xc7, 0xd9, 0xe8,
	0x26, 0x51, 0x83, 0x2c, 0x72, 0x8f, 0x93, 0xb9, 0x91, 0x1b, 0x89, 0x12, 0xbe, 0x4a, 0xa0, 0xf0,
	0x83, 0xc6, 0x07, 0xdf, 0x79, 0x41, 0x3a, 0xe4, 0xa9, 0xe8, 0xfd, 0x9d, 0x3f, 0x7e, 0x21, 0xdc,
	0x2a, 0xb9, 0xa2, 0xe0, 0x04, 0xc6, 0x39, 0x13, 0xd7, 0x1f, 0xcd, 0x49, 0xc8, 0xe1, 0x7e, 0x49,
	0x38, 0x81, 0xa1, 0x32, 0xa8, 0x41, 0x4e, 0xc3, 0x9d, 0x10, 0xfe, 0x1c, 0xb9, 0x72, 0x84, 0xe3,
	0x10, 0x67, 0x38, 0xfe, 0x62, 0x44, 0xbc, 0x80, 0x91, 0x29, 0xcb, 0x15, 0x84, 0xe3, 0x90, 0x7e,
	0x07, 0x85, 0xd6, 0x8c, 0xcc, 0x27, 0x75, 0xc6, 0xbc, 0xd9, 0xc8, 0x67, 0x84, 0xa2, 0xdf, 0x21,
	0x63, 0x7d, 0x5a, 0x06, 0xcd, 0x3f, 0xac, 0x9d, 0x25, 0xcb, 0x5b, 0x93, 0x39, 0x05, 0x0b, 0xa2,
	0xfe, 0x4d, 0x02, 0x45, 0xe0, 0xd1, 0x40, 0xee, 0xcc, 0xce, 0xbf, 0x90, 0xa7, 0x64, 0x61, 0x3b,
	0x6c, 0x36, 0x16, 0xd2, 0x69, 0x21, 0x5d, 0xda, 0x76, 0x7d, 0xc3, 0xc0, 0x09, 0x3e, 0x6a, 0x43,
	0x61, 0x9a, 0x7c, 0x65, 0x68, 0xfe, 0xaf, 0x3f, 0x79, 0x5d, 0x40, 0xc2, 0xdb, 0x59, 0xfc, 0x71,
	0xcc, 0x7e, 0x0e, 0x9c, 0x50, 0xb0, 0x88, 0xf5, 0x29, 0x14, 0xda, 0x84, 0x05, 0x13, 0x46, 0x97,
	0xae, 0x43, 0x09, 0xba, 0x06, 0x65, 0x1a, 0x15, 0x24, 0xda, 0xb3, 0x33, 0xaa, 0xeb, 0x7a, 0xf1,
	0x86, 0xc9, 0x17, 0x80, 0xd9, 0xa3, 0x39, 0x31, 0x79, 0xfd, 0xe1, 0xde, 0xad, 0x01, 0xfd, 0x11,
	0x72, 0x5d, 0x12, 0xae, 0xca, 0x5b, 0x26, 0x15, 0x21, 0xbb, 0x22, 0x1e, 0x9f, 0xb5, 0x30, 0x37,
	0xfa, 0xe4, 0xba, 0x13, 0xb2, 0x22, 0x73, 0x77, 0x49, 0xbc, 0x70, 0x6b, 0x37, 0x80, 0x7e, 0x04,
	0x85, 0x48, 0x37, 0x5c, 0x91, 0x8b, 0xff, 0x20, 0x1f, 0x77, 0x13, 0xa9, 0x90, 0x6d, 0x1a, 0xad,
	0xfa, 0xe0, 0xde, 0xd2, 0x52, 0xe8, 0x37, 0x38, 0x1b, 0x98, 0x9d, 0xa7, 0x61, 0xdf, 0x68, 0xf4,
	0xcc, 0x66, 0x7f, 0xd8, 0xef, 0x98, 0x0d, 0x63, 0x78, 0xf5, 0xd7, 0xed, 0xe5, 0x70, 0x60, 0x35,
	0x34, 0x09, 0xe5, 0x21, 0xd7, 0xe9, 0xf7, 0x86, 0x7f, 0xde, 0x5c, 0x5e, 0x69, 0xe9, 0x8b, 0xcf,
	0x12, 0x1c, 0x24, 0xba, 0xce, 0xd5, 0x06, 0xe6, 0xff, 0x66, 0xef, 0x9d, 0xa9, 0xa5, 0x50, 0x0e,
	0x32, 0x96, 0xf1, 0x64, 0x69, 0x12, 0x8f, 0xb0, 0x51, 0xbf, 0xd7, 0xd2, 0x3c, 0x6a, 0xd6, 0x2d,
	0x43, 0x93, 0xc5, 0x69, 0xa7, 0x6b, 0x68, 0x19, 0x74, 0x00, 0x0a, 0x8f, 0xfa, 0x56, 0xbd, 0xfb,
	0xa0, 0xed, 0x89, 0x3b, 0x4c, 0xcb, 0xc0, 0x8f, 0xf5, 0x7b, 0x6d, 0x9f, 0x2b, 0xf2, 0xaf, 0xb6,
	0x81, 0x35, 0x40, 0x59, 0x90, 0x5b, 0x9d, 0x27, 0x4d, 0x45, 0x0a, 0xec, 0x75, 0x7b, 0xa6, 0xf1,
	0x5e, 0xcb, 0xd7, 0xbe, 0x48, 0xa0, 0x84, 0x4b, 0xed, 0x7a, 0xa8, 0x0e, 0xd9, 0xb0, 0x63, 0xe8,
	0x74, 0x77, 0xfb, 0x42, 0x13, 0x4a, 0x27, 0xbb, 0x47, 0x62, 0xff, 0xf4, 0xd4, 0xa5, 0x84, 0x5a,
	0xa0, 0xb6, 0x09, 0x5b, 0xf7, 0x63, 0x6b, 0x8e, 0xb6, 0xfc, 0x2c, 0x1d, 0xbf, 0x7d, 0xac, 0xa7,
	0x46, 0xfb, 0xe2, 0x87, 0xf0, 0xc7, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x88, 0x17, 0xf6, 0x71,
	0x25, 0x06, 0x00, 0x00,
}

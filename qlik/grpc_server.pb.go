// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc_server.proto

/*
Package qlik is a generated protocol buffer package.

It is generated from these files:
	grpc_server.proto

It has these top-level messages:
	ConnectionInfo
	SessionInfo
	DataInfo
	GetDataOptions
	DataChunk
	FieldAttributes
	FieldInfo
	GetDataResponse
*/
package qlik

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// * How to interpret the data.
// If dates or times are already in the Qlik Engine format (fractional day since 1899-12-30), then the fastest way
// to import is to use SemanticType=DEFAULT. And transferr the date as a double and set FieldAttributes::Type = DATE.
// If the dates are in "days since 1904-01-01" format the best way is to add 1462 to them and send as
// 1899-12-30 dates.
type SemanticType int32

const (
	SemanticType_DEFAULT                     SemanticType = 0
	SemanticType_UNIX_SECONDS_SINCE_1970_UTC SemanticType = 1
	SemanticType_ISO_8601                    SemanticType = 2
)

var SemanticType_name = map[int32]string{
	0: "DEFAULT",
	1: "UNIX_SECONDS_SINCE_1970_UTC",
	2: "ISO_8601",
}
var SemanticType_value = map[string]int32{
	"DEFAULT":                     0,
	"UNIX_SECONDS_SINCE_1970_UTC": 1,
	"ISO_8601":                    2,
}

func (x SemanticType) String() string {
	return proto.EnumName(SemanticType_name, int32(x))
}
func (SemanticType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// * Direct copy of FieldAttrType in Qlik Engine. How to display the data.
type FieldAttrType int32

const (
	FieldAttrType_UNKNOWN   FieldAttrType = 0
	FieldAttrType_TEXT      FieldAttrType = 1
	FieldAttrType_REAL      FieldAttrType = 2
	FieldAttrType_DATE      FieldAttrType = 3
	FieldAttrType_TIME      FieldAttrType = 4
	FieldAttrType_TIMESTAMP FieldAttrType = 5
	FieldAttrType_INTERVAL  FieldAttrType = 6
	FieldAttrType_INTEGER   FieldAttrType = 10
	FieldAttrType_FIX       FieldAttrType = 11
	FieldAttrType_MONEY     FieldAttrType = 12
)

var FieldAttrType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "TEXT",
	2:  "REAL",
	3:  "DATE",
	4:  "TIME",
	5:  "TIMESTAMP",
	6:  "INTERVAL",
	10: "INTEGER",
	11: "FIX",
	12: "MONEY",
}
var FieldAttrType_value = map[string]int32{
	"UNKNOWN":   0,
	"TEXT":      1,
	"REAL":      2,
	"DATE":      3,
	"TIME":      4,
	"TIMESTAMP": 5,
	"INTERVAL":  6,
	"INTEGER":   10,
	"FIX":       11,
	"MONEY":     12,
}

func (x FieldAttrType) String() string {
	return proto.EnumName(FieldAttrType_name, int32(x))
}
func (FieldAttrType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ConnectionInfo struct {
	ConnectionString string `protobuf:"bytes,1,opt,name=connectionString" json:"connectionString,omitempty"`
	User             string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Password         string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
}

func (m *ConnectionInfo) Reset()                    { *m = ConnectionInfo{} }
func (m *ConnectionInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnectionInfo) ProtoMessage()               {}
func (*ConnectionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConnectionInfo) GetConnectionString() string {
	if m != nil {
		return m.ConnectionString
	}
	return ""
}

func (m *ConnectionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ConnectionInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type SessionInfo struct {
	User      string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	SessionId string `protobuf:"bytes,2,opt,name=sessionId" json:"sessionId,omitempty"`
	DocId     string `protobuf:"bytes,3,opt,name=docId" json:"docId,omitempty"`
}

func (m *SessionInfo) Reset()                    { *m = SessionInfo{} }
func (m *SessionInfo) String() string            { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()               {}
func (*SessionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *SessionInfo) GetDocId() string {
	if m != nil {
		return m.DocId
	}
	return ""
}

type DataInfo struct {
	Statement           string `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
	StatementParameters string `protobuf:"bytes,2,opt,name=statementParameters" json:"statementParameters,omitempty"`
}

func (m *DataInfo) Reset()                    { *m = DataInfo{} }
func (m *DataInfo) String() string            { return proto.CompactTextString(m) }
func (*DataInfo) ProtoMessage()               {}
func (*DataInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DataInfo) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *DataInfo) GetStatementParameters() string {
	if m != nil {
		return m.StatementParameters
	}
	return ""
}

type GetDataOptions struct {
	Connection  *ConnectionInfo `protobuf:"bytes,1,opt,name=connection" json:"connection,omitempty"`
	SessionInfo *SessionInfo    `protobuf:"bytes,2,opt,name=sessionInfo" json:"sessionInfo,omitempty"`
	Parameters  *DataInfo       `protobuf:"bytes,3,opt,name=parameters" json:"parameters,omitempty"`
}

func (m *GetDataOptions) Reset()                    { *m = GetDataOptions{} }
func (m *GetDataOptions) String() string            { return proto.CompactTextString(m) }
func (*GetDataOptions) ProtoMessage()               {}
func (*GetDataOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetDataOptions) GetConnection() *ConnectionInfo {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *GetDataOptions) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

func (m *GetDataOptions) GetParameters() *DataInfo {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// *
// A structure for streaming field values.
//
// This message conatins two parts. A value bucket part and a code part.
//
// Every transferred value have a string code and one or two numeric codes.
// These codes can be negative to inicate special things. -1 indicates null for example.
//
// Otherwise they can index into the value buckets.
// A value with a null string and a null number is a null value in the Qlik Engine.
//
// Number code have a special mechanism to escape an integer value inline with -2.
//
// Each chunk starts anywhere in any row and continues for an arbitary length and may wrap to
// another row. A DataChunk will typically transfer many rows.
//
// Each DataChunk must be equal or less in size to the default Grpc message size limit. This is
// currently 4 MB.
//
// But anything from 30 KB to 64 KB is preffered by the Grpc protocol. Most of the messages
// should be within the prefered size for best performance.
//
// Very large strings can be sent in many DataChunk messages by using the -3 escape sequence.
type DataChunk struct {
	// Value buckets
	StringBucket []string  `protobuf:"bytes,1,rep,name=stringBucket" json:"stringBucket,omitempty"`
	DoubleBucket []float64 `protobuf:"fixed64,2,rep,packed,name=doubleBucket" json:"doubleBucket,omitempty"`
	// Code arrays
	StringCodes []int32 `protobuf:"zigzag32,3,rep,packed,name=stringCodes" json:"stringCodes,omitempty"`
	NumberCodes []int64 `protobuf:"zigzag64,4,rep,packed,name=numberCodes" json:"numberCodes,omitempty"`
}

func (m *DataChunk) Reset()                    { *m = DataChunk{} }
func (m *DataChunk) String() string            { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()               {}
func (*DataChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DataChunk) GetStringBucket() []string {
	if m != nil {
		return m.StringBucket
	}
	return nil
}

func (m *DataChunk) GetDoubleBucket() []float64 {
	if m != nil {
		return m.DoubleBucket
	}
	return nil
}

func (m *DataChunk) GetStringCodes() []int32 {
	if m != nil {
		return m.StringCodes
	}
	return nil
}

func (m *DataChunk) GetNumberCodes() []int64 {
	if m != nil {
		return m.NumberCodes
	}
	return nil
}

// * Subset of classic Qlik Engine number format
type FieldAttributes struct {
	Type FieldAttrType `protobuf:"varint,1,opt,name=Type,enum=qlik.FieldAttrType" json:"Type,omitempty"`
}

func (m *FieldAttributes) Reset()                    { *m = FieldAttributes{} }
func (m *FieldAttributes) String() string            { return proto.CompactTextString(m) }
func (*FieldAttributes) ProtoMessage()               {}
func (*FieldAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FieldAttributes) GetType() FieldAttrType {
	if m != nil {
		return m.Type
	}
	return FieldAttrType_UNKNOWN
}

type FieldInfo struct {
	Name            string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	SemanticType    SemanticType     `protobuf:"varint,2,opt,name=semanticType,enum=qlik.SemanticType" json:"semanticType,omitempty"`
	FieldAttributes *FieldAttributes `protobuf:"bytes,3,opt,name=fieldAttributes" json:"fieldAttributes,omitempty"`
	Tags            []string         `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *FieldInfo) Reset()                    { *m = FieldInfo{} }
func (m *FieldInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldInfo) ProtoMessage()               {}
func (*FieldInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FieldInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldInfo) GetSemanticType() SemanticType {
	if m != nil {
		return m.SemanticType
	}
	return SemanticType_DEFAULT
}

func (m *FieldInfo) GetFieldAttributes() *FieldAttributes {
	if m != nil {
		return m.FieldAttributes
	}
	return nil
}

func (m *FieldInfo) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// * Transferred as initial metadata with the name "x-qlik-getdata-bin".
type GetDataResponse struct {
	FieldInfo []*FieldInfo `protobuf:"bytes,1,rep,name=fieldInfo" json:"fieldInfo,omitempty"`
	TableName string       `protobuf:"bytes,2,opt,name=tableName" json:"tableName,omitempty"`
}

func (m *GetDataResponse) Reset()                    { *m = GetDataResponse{} }
func (m *GetDataResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDataResponse) ProtoMessage()               {}
func (*GetDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetDataResponse) GetFieldInfo() []*FieldInfo {
	if m != nil {
		return m.FieldInfo
	}
	return nil
}

func (m *GetDataResponse) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func init() {
	proto.RegisterType((*ConnectionInfo)(nil), "qlik.ConnectionInfo")
	proto.RegisterType((*SessionInfo)(nil), "qlik.SessionInfo")
	proto.RegisterType((*DataInfo)(nil), "qlik.DataInfo")
	proto.RegisterType((*GetDataOptions)(nil), "qlik.GetDataOptions")
	proto.RegisterType((*DataChunk)(nil), "qlik.DataChunk")
	proto.RegisterType((*FieldAttributes)(nil), "qlik.FieldAttributes")
	proto.RegisterType((*FieldInfo)(nil), "qlik.FieldInfo")
	proto.RegisterType((*GetDataResponse)(nil), "qlik.GetDataResponse")
	proto.RegisterEnum("qlik.SemanticType", SemanticType_name, SemanticType_value)
	proto.RegisterEnum("qlik.FieldAttrType", FieldAttrType_name, FieldAttrType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Connector service

type ConnectorClient interface {
	// * The standard way to send data.
	// First send GetDataResponse as initial meta data.
	// Then send DataChunk stream.
	GetData(ctx context.Context, in *GetDataOptions, opts ...grpc.CallOption) (Connector_GetDataClient, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) GetData(ctx context.Context, in *GetDataOptions, opts ...grpc.CallOption) (Connector_GetDataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Connector_serviceDesc.Streams[0], c.cc, "/qlik.Connector/GetData", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorGetDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connector_GetDataClient interface {
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type connectorGetDataClient struct {
	grpc.ClientStream
}

func (x *connectorGetDataClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Connector service

type ConnectorServer interface {
	// * The standard way to send data.
	// First send GetDataResponse as initial meta data.
	// Then send DataChunk stream.
	GetData(*GetDataOptions, Connector_GetDataServer) error
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_GetData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDataOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectorServer).GetData(m, &connectorGetDataServer{stream})
}

type Connector_GetDataServer interface {
	Send(*DataChunk) error
	grpc.ServerStream
}

type connectorGetDataServer struct {
	grpc.ServerStream
}

func (x *connectorGetDataServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qlik.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetData",
			Handler:       _Connector_GetData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc_server.proto",
}

func init() { proto.RegisterFile("grpc_server.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 669 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0xad, 0xe3, 0xb4, 0x8d, 0xc7, 0x69, 0xb2, 0xdd, 0xf6, 0x93, 0xaa, 0x7e, 0x48, 0x44, 0xbe,
	0x21, 0xaa, 0x44, 0x94, 0xa6, 0x55, 0xf9, 0xb9, 0x41, 0x26, 0x71, 0x2b, 0x43, 0xeb, 0x54, 0x6b,
	0x07, 0x0a, 0x17, 0x44, 0x4e, 0xb2, 0x2d, 0x51, 0x13, 0xdb, 0x78, 0x37, 0x20, 0x6e, 0x79, 0x09,
	0x1e, 0x02, 0x1e, 0x12, 0xed, 0xda, 0x8e, 0xed, 0xc2, 0xdd, 0xec, 0x99, 0x33, 0x67, 0x76, 0x8e,
	0x67, 0x0d, 0xbb, 0x77, 0x71, 0x34, 0x1d, 0x33, 0x1a, 0x7f, 0xa5, 0x71, 0x27, 0x8a, 0x43, 0x1e,
	0xe2, 0xea, 0x97, 0xc5, 0xfc, 0xde, 0x58, 0x40, 0xa3, 0x1f, 0x06, 0x01, 0x9d, 0xf2, 0x79, 0x18,
	0xd8, 0xc1, 0x6d, 0x88, 0x8f, 0x00, 0x4d, 0xd7, 0x88, 0xcb, 0xe3, 0x79, 0x70, 0x77, 0xa0, 0xb4,
	0x94, 0xb6, 0x46, 0xfe, 0xc2, 0x31, 0x86, 0xea, 0x8a, 0xd1, 0xf8, 0xa0, 0x22, 0xf3, 0x32, 0xc6,
	0x87, 0x50, 0x8b, 0x7c, 0xc6, 0xbe, 0x85, 0xf1, 0xec, 0x40, 0x95, 0xf8, 0xfa, 0x6c, 0x8c, 0x40,
	0x77, 0x29, 0x63, 0x59, 0xab, 0xac, 0x5c, 0x29, 0x94, 0x3f, 0x02, 0x8d, 0xa5, 0x94, 0x59, 0xaa,
	0x9b, 0x03, 0x78, 0x1f, 0x36, 0x67, 0xe1, 0xd4, 0xce, 0x94, 0x93, 0x83, 0xf1, 0x11, 0x6a, 0x03,
	0x9f, 0xfb, 0x52, 0x53, 0xd4, 0x73, 0x9f, 0xd3, 0x25, 0x0d, 0x78, 0x2a, 0x9c, 0x03, 0xb8, 0x0b,
	0x7b, 0xeb, 0xc3, 0xb5, 0x1f, 0xfb, 0x4b, 0xca, 0x69, 0xcc, 0xd2, 0x3e, 0xff, 0x4a, 0x19, 0xbf,
	0x14, 0x68, 0x5c, 0x50, 0x2e, 0xf4, 0x87, 0x91, 0x18, 0x9d, 0xe1, 0x53, 0x80, 0xdc, 0x09, 0xd9,
	0x43, 0xef, 0xed, 0x77, 0x84, 0x9d, 0x9d, 0xb2, 0x97, 0xa4, 0xc0, 0xc3, 0x27, 0xa0, 0xb3, 0x7c,
	0x76, 0xd9, 0x52, 0xef, 0xed, 0x26, 0x65, 0x05, 0x53, 0x48, 0x91, 0x85, 0x3b, 0x00, 0x51, 0x7e,
	0x4d, 0x55, 0xd6, 0x34, 0x92, 0x9a, 0x6c, 0x62, 0x52, 0x60, 0x18, 0x3f, 0x15, 0xd0, 0x44, 0xa2,
	0xff, 0x79, 0x15, 0xdc, 0x63, 0x03, 0xea, 0x4c, 0x7e, 0xa8, 0xd7, 0xab, 0xe9, 0x3d, 0x15, 0x76,
	0xa8, 0x6d, 0x8d, 0x94, 0x30, 0xc1, 0x99, 0x85, 0xab, 0xc9, 0x82, 0xa6, 0x9c, 0x4a, 0x4b, 0x6d,
	0x2b, 0xa4, 0x84, 0xe1, 0x16, 0xe8, 0x49, 0x4d, 0x3f, 0x9c, 0x51, 0x71, 0x0d, 0xb5, 0xbd, 0x4b,
	0x8a, 0x90, 0x60, 0x04, 0xab, 0xe5, 0x84, 0xc6, 0x09, 0xa3, 0xda, 0x52, 0xdb, 0x98, 0x14, 0x21,
	0xe3, 0x25, 0x34, 0xcf, 0xe7, 0x74, 0x31, 0x33, 0x39, 0x8f, 0xe7, 0x93, 0x15, 0xa7, 0x0c, 0x3f,
	0x81, 0xaa, 0xf7, 0x3d, 0xa2, 0xd2, 0xc1, 0x46, 0x6f, 0x2f, 0x19, 0x6b, 0x4d, 0x12, 0x29, 0x22,
	0x09, 0xc6, 0x6f, 0x05, 0x34, 0x89, 0x67, 0x5b, 0x13, 0xf8, 0x4b, 0x9a, 0x6d, 0x8d, 0x88, 0xf1,
	0x19, 0xd4, 0x19, 0x5d, 0xfa, 0x01, 0x9f, 0x4f, 0xa5, 0x64, 0x45, 0x4a, 0xe2, 0xcc, 0xdd, 0x3c,
	0x43, 0x4a, 0x3c, 0xfc, 0x0a, 0x9a, 0xb7, 0xe5, 0x5b, 0xa5, 0x26, 0xff, 0xf7, 0xe0, 0x36, 0x49,
	0x92, 0x3c, 0x64, 0x8b, 0xcb, 0x70, 0xff, 0x2e, 0x99, 0x58, 0x23, 0x32, 0x36, 0x3e, 0x41, 0x33,
	0xdd, 0x18, 0x42, 0x59, 0x14, 0x06, 0x8c, 0xe2, 0xa7, 0xa0, 0xdd, 0x66, 0x03, 0xc8, 0xcf, 0xa0,
	0xf7, 0x9a, 0x85, 0x0e, 0xf2, 0x3b, 0xe6, 0x0c, 0xb1, 0xc4, 0xdc, 0x9f, 0x2c, 0xa8, 0x23, 0xe6,
	0x4c, 0x1f, 0xc1, 0x1a, 0x38, 0x7a, 0x03, 0xf5, 0xe2, 0x48, 0x58, 0x87, 0xed, 0x81, 0x75, 0x6e,
	0x8e, 0x2e, 0x3d, 0xb4, 0x81, 0x1f, 0xc3, 0xff, 0x23, 0xc7, 0xbe, 0x19, 0xbb, 0x56, 0x7f, 0xe8,
	0x0c, 0xdc, 0xb1, 0x6b, 0x3b, 0x7d, 0x6b, 0x7c, 0xfc, 0xe2, 0x59, 0x77, 0x3c, 0xf2, 0xfa, 0x48,
	0xc1, 0x75, 0xa8, 0xd9, 0xee, 0x70, 0xfc, 0xfc, 0xac, 0x7b, 0x8c, 0x2a, 0x47, 0x3f, 0x14, 0xd8,
	0x29, 0x59, 0x2e, 0xd4, 0x46, 0xce, 0x5b, 0x67, 0xf8, 0xde, 0x41, 0x1b, 0xb8, 0x06, 0x55, 0xcf,
	0xba, 0xf1, 0x90, 0x22, 0x22, 0x62, 0x99, 0x97, 0xa8, 0x22, 0xa2, 0x81, 0xe9, 0x59, 0x48, 0x95,
	0x59, 0xfb, 0xca, 0x42, 0x55, 0xbc, 0x03, 0x9a, 0x88, 0x5c, 0xcf, 0xbc, 0xba, 0x46, 0x9b, 0xb2,
	0x87, 0xe3, 0x59, 0xe4, 0x9d, 0x79, 0x89, 0xb6, 0x84, 0xa2, 0x38, 0x5d, 0x58, 0x04, 0x01, 0xde,
	0x06, 0xf5, 0xdc, 0xbe, 0x41, 0x3a, 0xd6, 0x60, 0xf3, 0x6a, 0xe8, 0x58, 0x1f, 0x50, 0xbd, 0x67,
	0x82, 0x96, 0x3e, 0x9c, 0x30, 0xc6, 0xa7, 0xb0, 0x9d, 0xba, 0x87, 0xd3, 0x47, 0x55, 0x7e, 0x7e,
	0x87, 0xcd, 0x7c, 0xff, 0xe5, 0x9a, 0x1b, 0x1b, 0x5d, 0x65, 0xb2, 0x25, 0x7f, 0x6a, 0x27, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0xfd, 0x8d, 0x48, 0x58, 0xe9, 0x04, 0x00, 0x00,
}

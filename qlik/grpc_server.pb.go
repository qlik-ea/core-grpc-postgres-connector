// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc_server.proto

/*
Package qlik is a generated protocol buffer package.

It is generated from these files:
	grpc_server.proto

It has these top-level messages:
	ConnectionInfo
	GenericCommand
	GenericCommandResponse
	SessionInfo
	DataInfo
	GetDataOptions
	Column
	DataChunk
	FieldAttributes
	FieldInfo
	GetDataResponse
*/
package qlik

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ValueFlag int32

const (
	ValueFlag_Normal     ValueFlag = 0
	ValueFlag_Null       ValueFlag = 1
	ValueFlag_NullString ValueFlag = 2
	ValueFlag_NullNum    ValueFlag = 3
)

var ValueFlag_name = map[int32]string{
	0: "Normal",
	1: "Null",
	2: "NullString",
	3: "NullNum",
}
var ValueFlag_value = map[string]int32{
	"Normal":     0,
	"Null":       1,
	"NullString": 2,
	"NullNum":    3,
}

func (x ValueFlag) String() string {
	return proto.EnumName(ValueFlag_name, int32(x))
}
func (ValueFlag) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type SemanticType int32

const (
	SemanticType_DEFAULT                     SemanticType = 0
	SemanticType_UNIX_SECONDS_SINCE_1970_UTC SemanticType = 1
	SemanticType_ISO_8601                    SemanticType = 2
)

var SemanticType_name = map[int32]string{
	0: "DEFAULT",
	1: "UNIX_SECONDS_SINCE_1970_UTC",
	2: "ISO_8601",
}
var SemanticType_value = map[string]int32{
	"DEFAULT":                     0,
	"UNIX_SECONDS_SINCE_1970_UTC": 1,
	"ISO_8601":                    2,
}

func (x SemanticType) String() string {
	return proto.EnumName(SemanticType_name, int32(x))
}
func (SemanticType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type FieldAttrType int32

const (
	FieldAttrType_UNKNOWN   FieldAttrType = 0
	FieldAttrType_TEXT      FieldAttrType = 1
	FieldAttrType_REAL      FieldAttrType = 2
	FieldAttrType_DATE      FieldAttrType = 3
	FieldAttrType_TIME      FieldAttrType = 4
	FieldAttrType_TIMESTAMP FieldAttrType = 5
	FieldAttrType_INTERVAL  FieldAttrType = 6
	FieldAttrType_INTEGER   FieldAttrType = 10
	FieldAttrType_FIX       FieldAttrType = 11
	FieldAttrType_MONEY     FieldAttrType = 12
)

var FieldAttrType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "TEXT",
	2:  "REAL",
	3:  "DATE",
	4:  "TIME",
	5:  "TIMESTAMP",
	6:  "INTERVAL",
	10: "INTEGER",
	11: "FIX",
	12: "MONEY",
}
var FieldAttrType_value = map[string]int32{
	"UNKNOWN":   0,
	"TEXT":      1,
	"REAL":      2,
	"DATE":      3,
	"TIME":      4,
	"TIMESTAMP": 5,
	"INTERVAL":  6,
	"INTEGER":   10,
	"FIX":       11,
	"MONEY":     12,
}

func (x FieldAttrType) String() string {
	return proto.EnumName(FieldAttrType_name, int32(x))
}
func (FieldAttrType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ConnectionInfo struct {
	ConnectionString string `protobuf:"bytes,1,opt,name=connectionString" json:"connectionString,omitempty"`
	User             string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Password         string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
}

func (m *ConnectionInfo) Reset()                    { *m = ConnectionInfo{} }
func (m *ConnectionInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnectionInfo) ProtoMessage()               {}
func (*ConnectionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ConnectionInfo) GetConnectionString() string {
	if m != nil {
		return m.ConnectionString
	}
	return ""
}

func (m *ConnectionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ConnectionInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type GenericCommand struct {
	Command    string          `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	Method     string          `protobuf:"bytes,2,opt,name=method" json:"method,omitempty"`
	Parameters []string        `protobuf:"bytes,3,rep,name=parameters" json:"parameters,omitempty"`
	Connection *ConnectionInfo `protobuf:"bytes,4,opt,name=connection" json:"connection,omitempty"`
}

func (m *GenericCommand) Reset()                    { *m = GenericCommand{} }
func (m *GenericCommand) String() string            { return proto.CompactTextString(m) }
func (*GenericCommand) ProtoMessage()               {}
func (*GenericCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GenericCommand) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *GenericCommand) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *GenericCommand) GetParameters() []string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *GenericCommand) GetConnection() *ConnectionInfo {
	if m != nil {
		return m.Connection
	}
	return nil
}

type GenericCommandResponse struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *GenericCommandResponse) Reset()                    { *m = GenericCommandResponse{} }
func (m *GenericCommandResponse) String() string            { return proto.CompactTextString(m) }
func (*GenericCommandResponse) ProtoMessage()               {}
func (*GenericCommandResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GenericCommandResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type SessionInfo struct {
	User      string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	SessionId string `protobuf:"bytes,2,opt,name=sessionId" json:"sessionId,omitempty"`
	DocId     string `protobuf:"bytes,3,opt,name=docId" json:"docId,omitempty"`
}

func (m *SessionInfo) Reset()                    { *m = SessionInfo{} }
func (m *SessionInfo) String() string            { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()               {}
func (*SessionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *SessionInfo) GetDocId() string {
	if m != nil {
		return m.DocId
	}
	return ""
}

type DataInfo struct {
	Statement           string `protobuf:"bytes,1,opt,name=statement" json:"statement,omitempty"`
	StatementParameters string `protobuf:"bytes,2,opt,name=statementParameters" json:"statementParameters,omitempty"`
}

func (m *DataInfo) Reset()                    { *m = DataInfo{} }
func (m *DataInfo) String() string            { return proto.CompactTextString(m) }
func (*DataInfo) ProtoMessage()               {}
func (*DataInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DataInfo) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *DataInfo) GetStatementParameters() string {
	if m != nil {
		return m.StatementParameters
	}
	return ""
}

type GetDataOptions struct {
	Connection  *ConnectionInfo `protobuf:"bytes,1,opt,name=connection" json:"connection,omitempty"`
	SessionInfo *SessionInfo    `protobuf:"bytes,2,opt,name=sessionInfo" json:"sessionInfo,omitempty"`
	Parameters  *DataInfo       `protobuf:"bytes,3,opt,name=parameters" json:"parameters,omitempty"`
}

func (m *GetDataOptions) Reset()                    { *m = GetDataOptions{} }
func (m *GetDataOptions) String() string            { return proto.CompactTextString(m) }
func (*GetDataOptions) ProtoMessage()               {}
func (*GetDataOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetDataOptions) GetConnection() *ConnectionInfo {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *GetDataOptions) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

func (m *GetDataOptions) GetParameters() *DataInfo {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type Column struct {
	Strings  []string    `protobuf:"bytes,1,rep,name=strings" json:"strings,omitempty"`
	Doubles  []float64   `protobuf:"fixed64,2,rep,packed,name=doubles" json:"doubles,omitempty"`
	Integers []int64     `protobuf:"zigzag64,3,rep,packed,name=integers" json:"integers,omitempty"`
	Flags    []ValueFlag `protobuf:"varint,4,rep,packed,name=flags,enum=qlik.ValueFlag" json:"flags,omitempty"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Column) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Column) GetDoubles() []float64 {
	if m != nil {
		return m.Doubles
	}
	return nil
}

func (m *Column) GetIntegers() []int64 {
	if m != nil {
		return m.Integers
	}
	return nil
}

func (m *Column) GetFlags() []ValueFlag {
	if m != nil {
		return m.Flags
	}
	return nil
}

type DataChunk struct {
	Cols []*Column `protobuf:"bytes,1,rep,name=cols" json:"cols,omitempty"`
}

func (m *DataChunk) Reset()                    { *m = DataChunk{} }
func (m *DataChunk) String() string            { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()               {}
func (*DataChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DataChunk) GetCols() []*Column {
	if m != nil {
		return m.Cols
	}
	return nil
}

type FieldAttributes struct {
	Type FieldAttrType `protobuf:"varint,1,opt,name=Type,enum=qlik.FieldAttrType" json:"Type,omitempty"`
}

func (m *FieldAttributes) Reset()                    { *m = FieldAttributes{} }
func (m *FieldAttributes) String() string            { return proto.CompactTextString(m) }
func (*FieldAttributes) ProtoMessage()               {}
func (*FieldAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FieldAttributes) GetType() FieldAttrType {
	if m != nil {
		return m.Type
	}
	return FieldAttrType_UNKNOWN
}

type FieldInfo struct {
	Name            string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	SemanticType    SemanticType     `protobuf:"varint,2,opt,name=semanticType,enum=qlik.SemanticType" json:"semanticType,omitempty"`
	FieldAttributes *FieldAttributes `protobuf:"bytes,3,opt,name=fieldAttributes" json:"fieldAttributes,omitempty"`
}

func (m *FieldInfo) Reset()                    { *m = FieldInfo{} }
func (m *FieldInfo) String() string            { return proto.CompactTextString(m) }
func (*FieldInfo) ProtoMessage()               {}
func (*FieldInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FieldInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldInfo) GetSemanticType() SemanticType {
	if m != nil {
		return m.SemanticType
	}
	return SemanticType_DEFAULT
}

func (m *FieldInfo) GetFieldAttributes() *FieldAttributes {
	if m != nil {
		return m.FieldAttributes
	}
	return nil
}

type GetDataResponse struct {
	FieldInfo []*FieldInfo `protobuf:"bytes,1,rep,name=fieldInfo" json:"fieldInfo,omitempty"`
	TableName string       `protobuf:"bytes,2,opt,name=tableName" json:"tableName,omitempty"`
}

func (m *GetDataResponse) Reset()                    { *m = GetDataResponse{} }
func (m *GetDataResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDataResponse) ProtoMessage()               {}
func (*GetDataResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetDataResponse) GetFieldInfo() []*FieldInfo {
	if m != nil {
		return m.FieldInfo
	}
	return nil
}

func (m *GetDataResponse) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func init() {
	proto.RegisterType((*ConnectionInfo)(nil), "qlik.ConnectionInfo")
	proto.RegisterType((*GenericCommand)(nil), "qlik.GenericCommand")
	proto.RegisterType((*GenericCommandResponse)(nil), "qlik.GenericCommandResponse")
	proto.RegisterType((*SessionInfo)(nil), "qlik.SessionInfo")
	proto.RegisterType((*DataInfo)(nil), "qlik.DataInfo")
	proto.RegisterType((*GetDataOptions)(nil), "qlik.GetDataOptions")
	proto.RegisterType((*Column)(nil), "qlik.Column")
	proto.RegisterType((*DataChunk)(nil), "qlik.DataChunk")
	proto.RegisterType((*FieldAttributes)(nil), "qlik.FieldAttributes")
	proto.RegisterType((*FieldInfo)(nil), "qlik.FieldInfo")
	proto.RegisterType((*GetDataResponse)(nil), "qlik.GetDataResponse")
	proto.RegisterEnum("qlik.ValueFlag", ValueFlag_name, ValueFlag_value)
	proto.RegisterEnum("qlik.SemanticType", SemanticType_name, SemanticType_value)
	proto.RegisterEnum("qlik.FieldAttrType", FieldAttrType_name, FieldAttrType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Connector service

type ConnectorClient interface {
	ExecuteGenericCommand(ctx context.Context, in *GenericCommand, opts ...grpc.CallOption) (*GenericCommandResponse, error)
	GetData(ctx context.Context, in *GetDataOptions, opts ...grpc.CallOption) (Connector_GetDataClient, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) ExecuteGenericCommand(ctx context.Context, in *GenericCommand, opts ...grpc.CallOption) (*GenericCommandResponse, error) {
	out := new(GenericCommandResponse)
	err := grpc.Invoke(ctx, "/qlik.Connector/ExecuteGenericCommand", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GetData(ctx context.Context, in *GetDataOptions, opts ...grpc.CallOption) (Connector_GetDataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Connector_serviceDesc.Streams[0], c.cc, "/qlik.Connector/GetData", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectorGetDataClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connector_GetDataClient interface {
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type connectorGetDataClient struct {
	grpc.ClientStream
}

func (x *connectorGetDataClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Connector service

type ConnectorServer interface {
	ExecuteGenericCommand(context.Context, *GenericCommand) (*GenericCommandResponse, error)
	GetData(*GetDataOptions, Connector_GetDataServer) error
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_ExecuteGenericCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).ExecuteGenericCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qlik.Connector/ExecuteGenericCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).ExecuteGenericCommand(ctx, req.(*GenericCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GetData_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDataOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectorServer).GetData(m, &connectorGetDataServer{stream})
}

type Connector_GetDataServer interface {
	Send(*DataChunk) error
	grpc.ServerStream
}

type connectorGetDataServer struct {
	grpc.ServerStream
}

func (x *connectorGetDataServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qlik.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ExecuteGenericCommand",
			Handler:    _Connector_ExecuteGenericCommand_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetData",
			Handler:       _Connector_GetData_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc_server.proto",
}

func init() { proto.RegisterFile("grpc_server.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 811 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x5b, 0x8f, 0xda, 0x46,
	0x14, 0x5e, 0x63, 0x2f, 0xbb, 0x3e, 0x10, 0x98, 0x4c, 0x2e, 0xb2, 0xb6, 0x51, 0x8b, 0x2c, 0x55,
	0x45, 0xab, 0x66, 0x45, 0x48, 0x94, 0x5e, 0x1e, 0x5a, 0x21, 0x30, 0x11, 0xed, 0x62, 0x22, 0x63,
	0xd2, 0x6d, 0x1f, 0x8a, 0x06, 0x33, 0x10, 0x2b, 0xbe, 0x50, 0xcf, 0xb8, 0x97, 0xa7, 0x4a, 0xfd,
	0x05, 0x7d, 0xec, 0x7f, 0xe8, 0x9f, 0xac, 0x66, 0x7c, 0x85, 0xe6, 0x21, 0x6f, 0xe7, 0x3e, 0xdf,
	0xf9, 0xce, 0x39, 0x36, 0xdc, 0xdf, 0x27, 0x07, 0x6f, 0xcd, 0x68, 0xf2, 0x2b, 0x4d, 0x6e, 0x0e,
	0x49, 0xcc, 0x63, 0xac, 0xfd, 0x12, 0xf8, 0xef, 0xcc, 0x00, 0x3a, 0xe3, 0x38, 0x8a, 0xa8, 0xc7,
	0xfd, 0x38, 0x9a, 0x45, 0xbb, 0x18, 0x5f, 0x03, 0xf2, 0x4a, 0xcb, 0x92, 0x27, 0x7e, 0xb4, 0x37,
	0x94, 0x9e, 0xd2, 0xd7, 0x9d, 0xff, 0xd9, 0x31, 0x06, 0x2d, 0x65, 0x34, 0x31, 0x1a, 0xd2, 0x2f,
	0x65, 0x7c, 0x05, 0x97, 0x07, 0xc2, 0xd8, 0x6f, 0x71, 0xb2, 0x35, 0x54, 0x69, 0x2f, 0x75, 0xf3,
	0x1f, 0x05, 0x3a, 0xaf, 0x68, 0x44, 0x13, 0xdf, 0x1b, 0xc7, 0x61, 0x48, 0xa2, 0x2d, 0x36, 0xe0,
	0xc2, 0xcb, 0xc4, 0xfc, 0x95, 0x42, 0xc5, 0x8f, 0xa1, 0x19, 0x52, 0xfe, 0x36, 0xde, 0xe6, 0xe5,
	0x73, 0x0d, 0x7f, 0x0c, 0x70, 0x20, 0x09, 0x09, 0x29, 0xa7, 0x09, 0x33, 0xd4, 0x9e, 0xda, 0xd7,
	0x9d, 0x9a, 0x05, 0xbf, 0x00, 0xa8, 0x80, 0x1a, 0x5a, 0x4f, 0xe9, 0xb7, 0x86, 0x0f, 0x6f, 0x44,
	0xb7, 0x37, 0xc7, 0xad, 0x3a, 0xb5, 0x38, 0xf3, 0x73, 0x78, 0x7c, 0x8c, 0xcc, 0xa1, 0xec, 0x10,
	0x47, 0x8c, 0x8a, 0x26, 0xb7, 0x84, 0x93, 0x1c, 0x9e, 0x94, 0xcd, 0x15, 0xb4, 0x96, 0x94, 0xb1,
	0x82, 0xb3, 0x82, 0x07, 0xa5, 0xc6, 0xc3, 0x13, 0xd0, 0x59, 0x1e, 0x52, 0x74, 0x50, 0x19, 0xf0,
	0x43, 0x38, 0xdf, 0xc6, 0xde, 0xac, 0xa0, 0x28, 0x53, 0xcc, 0x9f, 0xe0, 0x72, 0x42, 0x38, 0x91,
	0x35, 0x45, 0x3e, 0x27, 0x9c, 0x86, 0x34, 0xe2, 0x79, 0xe1, 0xca, 0x80, 0x07, 0xf0, 0xa0, 0x54,
	0x5e, 0x57, 0x6c, 0x64, 0xef, 0xbc, 0xcf, 0x65, 0xfe, 0x2b, 0xb9, 0xe7, 0xa2, 0xfe, 0xe2, 0x20,
	0x5a, 0x3e, 0x65, 0x4a, 0xf9, 0x30, 0xa6, 0xf0, 0x73, 0x68, 0xb1, 0xaa, 0x77, 0xf9, 0x64, 0x6b,
	0x78, 0x3f, 0x4b, 0xab, 0x91, 0xe2, 0xd4, 0xa3, 0xf0, 0xcd, 0xc9, 0xd0, 0x44, 0x4e, 0x27, 0xcb,
	0x29, 0x3a, 0xae, 0x0f, 0xd1, 0xfc, 0x13, 0x9a, 0xe3, 0x38, 0x48, 0xc3, 0x48, 0x2c, 0x08, 0x93,
	0xdb, 0xc6, 0x0c, 0x45, 0xce, 0xba, 0x50, 0x85, 0x67, 0x1b, 0xa7, 0x9b, 0x80, 0x8a, 0xbe, 0xd5,
	0xbe, 0xe2, 0x14, 0xaa, 0xd8, 0x41, 0x3f, 0xe2, 0x74, 0x5f, 0x2c, 0x08, 0x76, 0x4a, 0x1d, 0x7f,
	0x0a, 0xe7, 0xbb, 0x80, 0xec, 0x99, 0xa1, 0xf5, 0xd4, 0x7e, 0x67, 0xd8, 0xcd, 0x40, 0xbc, 0x21,
	0x41, 0x4a, 0xa7, 0x01, 0xd9, 0x3b, 0x99, 0xd7, 0x7c, 0x0a, 0xba, 0x00, 0x36, 0x7e, 0x9b, 0x46,
	0xef, 0x70, 0x0f, 0x34, 0x2f, 0x0e, 0x32, 0x00, 0xad, 0x61, 0xbb, 0xa0, 0x48, 0xe0, 0x73, 0xa4,
	0xc7, 0xfc, 0x1a, 0xba, 0x53, 0x9f, 0x06, 0xdb, 0x11, 0xe7, 0x89, 0xbf, 0x49, 0x39, 0x65, 0xf8,
	0x33, 0xd0, 0xdc, 0x3f, 0x0e, 0x54, 0xf2, 0xda, 0x19, 0x3e, 0xc8, 0x92, 0xca, 0x20, 0xe1, 0x72,
	0x64, 0x80, 0xb8, 0x0a, 0x5d, 0xda, 0x8b, 0x5d, 0x8a, 0x48, 0x48, 0x8b, 0x5d, 0x12, 0x32, 0x7e,
	0x09, 0x6d, 0x46, 0x43, 0x12, 0x71, 0xdf, 0x93, 0x25, 0x1b, 0xb2, 0x24, 0x2e, 0x38, 0xaf, 0x3c,
	0xce, 0x51, 0x1c, 0xfe, 0x16, 0xba, 0xbb, 0x63, 0x54, 0x39, 0xf5, 0x8f, 0x4e, 0xd0, 0x64, 0x4e,
	0xe7, 0x34, 0xda, 0xfc, 0x19, 0xba, 0xf9, 0xce, 0x94, 0xe7, 0xf0, 0x14, 0xf4, 0x5d, 0x01, 0x36,
	0x27, 0xa4, 0x5b, 0xab, 0x26, 0x27, 0x59, 0x45, 0x88, 0x35, 0xe6, 0x64, 0x13, 0x50, 0x5b, 0xf4,
	0x94, 0x9f, 0x41, 0x69, 0xb8, 0xfe, 0x06, 0xf4, 0x92, 0x79, 0x0c, 0xd0, 0xb4, 0xe3, 0x24, 0x24,
	0x01, 0x3a, 0xc3, 0x97, 0xa0, 0xd9, 0x69, 0x10, 0x20, 0x05, 0x77, 0x00, 0x84, 0x94, 0x7d, 0x71,
	0x50, 0x03, 0xb7, 0xe0, 0x42, 0xe8, 0x76, 0x1a, 0x22, 0xf5, 0xfa, 0x3b, 0x68, 0xd7, 0xdb, 0x17,
	0xce, 0x89, 0x35, 0x1d, 0xad, 0x6e, 0x5d, 0x74, 0x86, 0x3f, 0x81, 0x8f, 0x56, 0xf6, 0xec, 0x6e,
	0xbd, 0xb4, 0xc6, 0x0b, 0x7b, 0xb2, 0x5c, 0x2f, 0x67, 0xf6, 0xd8, 0x5a, 0x3f, 0xfb, 0xea, 0x8b,
	0xc1, 0x7a, 0xe5, 0x8e, 0x91, 0x82, 0xdb, 0x70, 0x39, 0x5b, 0x2e, 0xd6, 0x5f, 0xbe, 0x1c, 0x3c,
	0x43, 0x8d, 0xeb, 0xbf, 0x14, 0xb8, 0x77, 0x34, 0x1e, 0x51, 0x6d, 0x65, 0x7f, 0x6f, 0x2f, 0x7e,
	0xb0, 0x33, 0x44, 0xae, 0x75, 0xe7, 0x22, 0x45, 0x48, 0x8e, 0x35, 0xba, 0x45, 0x0d, 0x21, 0x4d,
	0x46, 0xae, 0x85, 0x54, 0xe9, 0x9d, 0xcd, 0x2d, 0xa4, 0xe1, 0x7b, 0xa0, 0x0b, 0x69, 0xe9, 0x8e,
	0xe6, 0xaf, 0xd1, 0xb9, 0x7c, 0xc3, 0x76, 0x2d, 0xe7, 0xcd, 0xe8, 0x16, 0x35, 0x45, 0x45, 0xa1,
	0xbd, 0xb2, 0x1c, 0x04, 0xf8, 0x02, 0xd4, 0xe9, 0xec, 0x0e, 0xb5, 0xb0, 0x0e, 0xe7, 0xf3, 0x85,
	0x6d, 0xfd, 0x88, 0xda, 0xc3, 0xbf, 0x15, 0xd0, 0xf3, 0xdb, 0x8b, 0x13, 0x3c, 0x87, 0x47, 0xd6,
	0xef, 0xd4, 0x4b, 0x39, 0x3d, 0xf9, 0x6a, 0xe6, 0x57, 0x7a, 0x6c, 0xbd, 0x7a, 0xf2, 0x3e, 0x6b,
	0x31, 0x38, 0xf3, 0x0c, 0xbf, 0x80, 0x8b, 0x7c, 0x9a, 0x55, 0x81, 0xfa, 0x07, 0xe1, 0xaa, 0x5b,
	0x5d, 0xa4, 0x5c, 0x7c, 0xf3, 0x6c, 0xa0, 0x6c, 0x9a, 0xf2, 0x7f, 0xf1, 0xfc, 0xbf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xcb, 0x0b, 0x75, 0x13, 0x44, 0x06, 0x00, 0x00,
}
